.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Manual::Tutorial::05_Authentication 3"
.TH Catalyst::Manual::Tutorial::05_Authentication 3 "2010-02-17" "perl v5.12.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Manual::Tutorial::05_Authentication \- Catalyst Tutorial \- Chapter 5: Authentication
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This is \fBChapter 5 of 10\fR for the Catalyst tutorial.
.PP
Tutorial Overview
.IP "1." 4
Introduction
.IP "2." 4
Catalyst Basics
.IP "3." 4
More Catalyst Basics
.IP "4." 4
Basic \s-1CRUD\s0
.IP "5." 4
\&\fB05_Authentication\fR
.IP "6." 4
Authorization
.IP "7." 4
Debugging
.IP "8." 4
Testing
.IP "9." 4
Advanced \s-1CRUD\s0
.IP "10." 4
Appendices
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Now that we finally have a simple yet functional application, we can
focus on providing authentication (with authorization coming next in
Chapter 6).
.PP
This chapter of the tutorial is divided into two main sections: 1) basic,
cleartext authentication and 2) hash-based authentication.
.PP
You can checkout the source code for this example from the catalyst
subversion repository as per the instructions in
Catalyst::Manual::Tutorial::01_Intro.
.SH "BASIC AUTHENTICATION"
.IX Header "BASIC AUTHENTICATION"
This section explores how to add authentication logic to a Catalyst
application.
.SS "Add Users and Roles to the Database"
.IX Subsection "Add Users and Roles to the Database"
First, we add both user and role information to the database (we will
add the role information here although it will not be used until the
authorization section, Chapter 6).  Create a new \s-1SQL\s0 script file by opening
\&\f(CW\*(C`myapp02.sql\*(C'\fR in your editor and insert:
.PP
.Vb 10
\&    \-\-
\&    \-\- Add user and role tables, along with a many\-to\-many join table
\&    \-\-
\&    PRAGMA foreign_keys = ON;
\&    CREATE TABLE user (
\&            id            INTEGER PRIMARY KEY,
\&            username      TEXT,
\&            password      TEXT,
\&            email_address TEXT,
\&            first_name    TEXT,
\&            last_name     TEXT,
\&            active        INTEGER
\&    );
\&    CREATE TABLE role (
\&            id   INTEGER PRIMARY KEY,
\&            role TEXT
\&    );
\&    CREATE TABLE user_role (
\&            user_id INTEGER REFERENCES user(id) ON DELETE CASCADE ON UPDATE CASCADE,
\&            role_id INTEGER REFERENCES role(id) ON DELETE CASCADE ON UPDATE CASCADE,
\&            PRIMARY KEY (user_id, role_id)
\&    );
\&    \-\-
\&    \-\- Load up some initial test data
\&    \-\-
\&    INSERT INTO user VALUES (1, \*(Aqtest01\*(Aq, \*(Aqmypass\*(Aq, \*(Aqt01@na.com\*(Aq, \*(AqJoe\*(Aq,  \*(AqBlow\*(Aq, 1);
\&    INSERT INTO user VALUES (2, \*(Aqtest02\*(Aq, \*(Aqmypass\*(Aq, \*(Aqt02@na.com\*(Aq, \*(AqJane\*(Aq, \*(AqDoe\*(Aq,  1);
\&    INSERT INTO user VALUES (3, \*(Aqtest03\*(Aq, \*(Aqmypass\*(Aq, \*(Aqt03@na.com\*(Aq, \*(AqNo\*(Aq,   \*(AqGo\*(Aq,   0);
\&    INSERT INTO role VALUES (1, \*(Aquser\*(Aq);
\&    INSERT INTO role VALUES (2, \*(Aqadmin\*(Aq);
\&    INSERT INTO user_role VALUES (1, 1);
\&    INSERT INTO user_role VALUES (1, 2);
\&    INSERT INTO user_role VALUES (2, 1);
\&    INSERT INTO user_role VALUES (3, 1);
.Ve
.PP
Then load this into the \f(CW\*(C`myapp.db\*(C'\fR database with the following command:
.PP
.Vb 1
\&    $ sqlite3 myapp.db < myapp02.sql
.Ve
.SS "Add User and Role Information to \s-1DBIC\s0 Schema"
.IX Subsection "Add User and Role Information to DBIC Schema"
Although we could manually edit the \s-1DBIC\s0 schema information to include
the new tables added in the previous step, let's use the \f(CW\*(C`create=static\*(C'\fR
option on the \s-1DBIC\s0 model helper to do most of the work for us:
.PP
.Vb 11
\&    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \e
\&        create=static components=TimeStamp dbi:SQLite:myapp.db \e
\&        on_connect_do="PRAGMA foreign_keys = ON"
\&     exists "/root/dev/MyApp/script/../lib/MyApp/Model"
\&     exists "/root/dev/MyApp/script/../t"
\&    Dumping manual schema for MyApp::Schema to directory /root/dev/MyApp/script/../lib ...
\&    Schema dump completed.
\&     exists "/root/dev/MyApp/script/../lib/MyApp/Model/DB.pm"
\&    $
\&    $ ls lib/MyApp/Schema/Result
\&    Author.pm  BookAuthor.pm  Book.pm  Role.pm  User.pm  UserRole.pm
.Ve
.PP
Notice how the helper has added three new table-specific Result Source
files to the \f(CW\*(C`lib/MyApp/Schema/Result\*(C'\fR directory.  And, more
importantly, even if there were changes to the existing result source
files, those changes would have only been written above the \f(CW\*(C`# DO NOT
MODIFY THIS OR ANYTHING ABOVE!\*(C'\fR comment and your hand-edited
enhancements would have been preserved.
.PP
Speaking of \*(L"hand-editted enhancements,\*(R" we should now add the 
\&\f(CW\*(C`many_to_many\*(C'\fR relationship information to the User Result Source file. 
As with the Book, BookAuthor, and Author files in 
Chapter 3, 
DBIx::Class::Schema::Loader has 
automatically created the \f(CW\*(C`has_many\*(C'\fR and \f(CW\*(C`belongs_to\*(C'\fR relationships 
for the new User, UserRole, and Role tables. However, as a convenience 
for mapping Users to their assigned roles (see 
Chapter 6), we will 
also manually add a \f(CW\*(C`many_to_many\*(C'\fR relationship. Edit 
\&\f(CW\*(C`lib/MyApp/Schema/Result/User.pm\*(C'\fR add the following information between 
the \f(CW\*(C`# DO NOT MODIFY THIS OR ANYTHING ABOVE!\*(C'\fR comment and the closing 
\&\f(CW\*(C`1;\*(C'\fR:
.PP
.Vb 7
\&    # many_to_many():
\&    #   args:
\&    #     1) Name of relationship, DBIC will create accessor with this name
\&    #     2) Name of has_many() relationship this many_to_many() is shortcut for
\&    #     3) Name of belongs_to() relationship in model class of has_many() above
\&    #   You must already have the has_many() defined to use a many_to_many().
\&    _\|_PACKAGE_\|_\->many_to_many(roles => \*(Aquser_roles\*(Aq, \*(Aqrole\*(Aq);
.Ve
.PP
The code for this update is obviously very similar to the edits we made 
to the \f(CW\*(C`Book\*(C'\fR and \f(CW\*(C`Author\*(C'\fR classes created in Chapter 3 with one 
exception: we only defined the \f(CW\*(C`many_to_many\*(C'\fR relationship in one 
direction. Whereas we felt that we would want to map Authors to Books 
\&\fB\s-1AND\s0\fR Books to Authors, here we are only adding the convenience 
\&\f(CW\*(C`many_to_many\*(C'\fR in the Users to Roles direction.
.PP
Note that we do not need to make any change to the
\&\f(CW\*(C`lib/MyApp/Schema.pm\*(C'\fR schema file.  It simply tells \s-1DBIC\s0 to load all
of the Result Class and ResultSet Class files it finds in below the
\&\f(CW\*(C`lib/MyApp/Schema\*(C'\fR directory, so it will automatically pick up our
new table information.
.SS "Sanity-Check of the Development Server Reload"
.IX Subsection "Sanity-Check of the Development Server Reload"
We aren't ready to try out the authentication just yet; we only want to 
do a quick check to be sure our model loads correctly. Assuming that you 
are following along and using the \*(L"\-r\*(R" option on \f(CW\*(C`myapp_server.pl\*(C'\fR, 
then the development server should automatically reload (if not, press 
\&\f(CW\*(C`Ctrl\-C\*(C'\fR to break out of the server if it's running and then enter 
\&\f(CW\*(C`script/myapp_server.pl\*(C'\fR to start it). Look for the three new model 
objects in the startup debug output:
.PP
.Vb 10
\&    ...
\&     .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-.
\&    | Class                                                             | Type     |
\&    +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&    | MyApp::Controller::Books                                          | instance |
\&    | MyApp::Controller::Root                                           | instance |
\&    | MyApp::Model::DB                                                  | instance |
\&    | MyApp::Model::DB::Author                                          | class    |
\&    | MyApp::Model::DB::Book                                            | class    |
\&    | MyApp::Model::DB::BookAuthor                                      | class    |
\&    | MyApp::Model::DB::Role                                            | class    |
\&    | MyApp::Model::DB::User                                            | class    |
\&    | MyApp::Model::DB::UserRole                                        | class    |
\&    | MyApp::View::TT                                                   | instance |
\&    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\*(Aq
\&    ...
.Ve
.PP
Again, notice that your \*(L"Result Class\*(R" classes have been \*(L"re-loaded\*(R"
by Catalyst under \f(CW\*(C`MyApp::Model\*(C'\fR.
.SS "Include Authentication and Session Plugins"
.IX Subsection "Include Authentication and Session Plugins"
Edit \f(CW\*(C`lib/MyApp.pm\*(C'\fR and update it as follows (everything below
\&\f(CW\*(C`StackTrace\*(C'\fR is new):
.PP
.Vb 5
\&    # Load plugins
\&    use Catalyst qw/
\&        \-Debug
\&        ConfigLoader
\&        Static::Simple
\&    
\&        StackTrace
\&    
\&        Authentication
\&    
\&        Session
\&        Session::Store::FastMmap
\&        Session::State::Cookie
\&    /;
.Ve
.PP
\&\fBNote:\fR As discussed in MoreCatalystBasics, different versions of
\&\f(CW\*(C`Catalyst::Devel\*(C'\fR have used a variety of methods to load the plugins,
but we are going to use the current Catalyst 5.8X practice of putting
them on the \f(CW\*(C`use Catalyst\*(C'\fR line.
.PP
The \f(CW\*(C`Authentication\*(C'\fR plugin supports Authentication while the
\&\f(CW\*(C`Session\*(C'\fR plugins are required to maintain state across multiple \s-1HTTP\s0
requests.
.PP
Note that the only required Authentication class is the main one. This
is a change that occurred in version 0.09999_01 of the
\&\f(CW\*(C`Authentication\*(C'\fR plugin. You \fBdo not need\fR to specify a particular
Authentication::Store or Authentication::Credential plugin. Instead,
indicate the Store and Credential you want to use in your application
configuration (see below).
.PP
Make sure you include the additional plugins as new dependencies in
the Makefile.PL file something like this:
.PP
.Vb 4
\&    requires \*(AqCatalyst::Plugin::Authentication\*(Aq;
\&    requires \*(AqCatalyst::Plugin::Session\*(Aq;
\&    requires \*(AqCatalyst::Plugin::Session::Store::FastMmap\*(Aq;
\&    requires \*(AqCatalyst::Plugin::Session::State::Cookie\*(Aq;
.Ve
.PP
Note that there are several options for
Session::Store.
Session::Store::Memcached or
Session::Store::FastMmap is
generally a good choice if you are on Unix.  If you are running on
Windows, try
Session::Store::File. Consult
Session::Store and its subclasses
for additional information and options (for example to use a database\-
backed session store).
.SS "Configure Authentication"
.IX Subsection "Configure Authentication"
There are a variety of ways to provide configuration information to
Catalyst::Plugin::Authentication.
Here we will use 
Catalyst::Authentication::Realm::SimpleDB
because it automatically sets a reasonable set of defaults for us. Open 
\&\f(CW\*(C`lib/MyApp.pm\*(C'\fR and place the following text above the call to
\&\f(CW\*(C`_\|_PACKAGE_\|_\->setup();\*(C'\fR:
.PP
.Vb 8
\&    # Configure SimpleDB Authentication
\&    _\|_PACKAGE_\|_\->config\->{\*(AqPlugin::Authentication\*(Aq} = {
\&            default => {
\&                class           => \*(AqSimpleDB\*(Aq,
\&                user_model      => \*(AqDB::User\*(Aq,
\&                password_type   => \*(Aqclear\*(Aq,
\&            },
\&        };
.Ve
.PP
We could have placed this configuration in \f(CW\*(C`myapp.conf\*(C'\fR, but placing 
it in \f(CW\*(C`lib/MyApp.pm\*(C'\fR is probably a better place since it's not likely 
something that users of your application will want to change during 
deployment (or you could use a mixture: leave \f(CW\*(C`class\*(C'\fR and 
\&\f(CW\*(C`user_model\*(C'\fR defined in \f(CW\*(C`lib/MyApp.pm\*(C'\fR as we show above, but place 
\&\f(CW\*(C`password_type\*(C'\fR in \f(CW\*(C`myapp.conf\*(C'\fR to allow the type of password to be 
easily modified during deployment).  We will stick with putting 
all of the authentication-related configuration in \f(CW\*(C`lib/MyApp.pm\*(C'\fR 
for the tutorial, but if you wish to use \f(CW\*(C`myapp.conf\*(C'\fR, just convert
to the following code:
.PP
.Vb 7
\&    <Plugin::Authentication>
\&        <default>
\&            password_type clear
\&            user_model    DB::User
\&            class         SimpleDB
\&        </default>
\&    </Plugin::Authentication>
.Ve
.PP
\&\fB\s-1TIP:\s0\fR Here is a short script that will dump the contents of 
\&\f(CW\*(C`MyApp\-\*(C'\fRconfig> to Config::General format in
\&\f(CW\*(C`myapp.conf\*(C'\fR:
.PP
.Vb 2
\&    $ CATALYST_DEBUG=0 perl \-Ilib \-e \*(Aquse MyApp; use Config::General; 
\&        Config::General\->new\->save_file("myapp.conf", MyApp\->config);\*(Aq
.Ve
.PP
\&\fB\s-1HOWEVER\s0\fR, if you try out the command above, be sure to delete the
\&\*(L"myapp.conf\*(R" command.  Otherwise, you will wind up with duplicate
configurations.
.PP
\&\fB\s-1NOTE:\s0\fR Because we are using SimpleDB along with a database layout 
that complies with its default assumptions: we don't need to specify
the names of the columns where our username and password information
is stored (hence, the \*(L"Simple\*(R" part of \*(L"SimpleDB\*(R").  That being said,
SimpleDB lets you specify that type of information if you need to.
Take a look at 
\&\f(CW\*(C`Catalyst::Authentication::Realm::SimpleDB|Catalyst::Authentication::Realm::SimpleDB\*(C'\fR
for details.
.SS "Add Login and Logout Controllers"
.IX Subsection "Add Login and Logout Controllers"
Use the Catalyst create script to create two stub controller files:
.PP
.Vb 2
\&    $ script/myapp_create.pl controller Login
\&    $ script/myapp_create.pl controller Logout
.Ve
.PP
You could easily use a single controller here.  For example, you could
have a \f(CW\*(C`User\*(C'\fR controller with both \f(CW\*(C`login\*(C'\fR and \f(CW\*(C`logout\*(C'\fR actions.
Remember, Catalyst is designed to be very flexible, and leaves such
matters up to you, the designer and programmer.
.PP
Then open \f(CW\*(C`lib/MyApp/Controller/Login.pm\*(C'\fR, locate the
\&\f(CW\*(C`sub index :Path :Args(0)\*(C'\fR method (or \f(CW\*(C`sub index : Private\*(C'\fR if you
are using an older version of Catalyst) that was automatically
inserted by the helpers when we created the Login controller above,
and update the definition of \f(CW\*(C`sub index\*(C'\fR to match:
.PP
.Vb 1
\&    =head2 index
\&    
\&    Login logic
\&    
\&    =cut
\&    
\&    sub index :Path :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Get the username and password from form
\&        my $username = $c\->request\->params\->{username};
\&        my $password = $c\->request\->params\->{password};
\&    
\&        # If the username and password values were found in form
\&        if ($username && $password) {
\&            # Attempt to log the user in
\&            if ($c\->authenticate({ username => $username,
\&                                   password => $password  } )) {
\&                # If successful, then let them use the application
\&                $c\->response\->redirect($c\->uri_for(
\&                    $c\->controller(\*(AqBooks\*(Aq)\->action_for(\*(Aqlist\*(Aq)));
\&                return;
\&            } else {
\&                # Set an error message
\&                $c\->stash(error_msg => "Bad username or password.");
\&            }
\&        } else {
\&            # Set an error message
\&            $c\->stash(error_msg => "Empty username or password.");
\&        }
\&    
\&        # If either of above don\*(Aqt work out, send to the login page
\&        $c\->stash(template => \*(Aqlogin.tt2\*(Aq);
\&    }
.Ve
.PP
Be sure to remove the 
\&\f(CW\*(C`$c\->response\->body(\*(AqMatched MyApp::Controller::Login in Login.\*(Aq);\*(C'\fR
line of the \f(CW\*(C`sub index\*(C'\fR.
.PP
This controller fetches the \f(CW\*(C`username\*(C'\fR and \f(CW\*(C`password\*(C'\fR values from the
login form and attempts to authenticate the user.  If successful, it
redirects the user to the book list page.  If the login fails, the user
will stay at the login page and receive an error message.  If the
\&\f(CW\*(C`username\*(C'\fR and \f(CW\*(C`password\*(C'\fR values are not present in the form, the
user will be taken to the empty login form.
.PP
Note that we could have used something like "\f(CW\*(C`sub default :Path\*(C'\fR",
however, it is generally recommended (partly for historical reasons,
and partly for code clarity) only to use \f(CW\*(C`default\*(C'\fR in
\&\f(CW\*(C`MyApp::Controller::Root\*(C'\fR, and then mainly to generate the 404 not
found page for the application.
.PP
Instead, we are using "\f(CW\*(C`sub somename :Path :Args(0) {...}\*(C'\fR" here to
specifically match the \s-1URL\s0 \f(CW\*(C`/login\*(C'\fR. \f(CW\*(C`Path\*(C'\fR actions (aka, \*(L"literal
actions\*(R") create \s-1URI\s0 matches relative to the namespace of the
controller where they are defined.  Although \f(CW\*(C`Path\*(C'\fR supports
arguments that allow relative and absolute paths to be defined, here
we use an empty \f(CW\*(C`Path\*(C'\fR definition to match on just the name of the
controller itself.  The method name, \f(CW\*(C`index\*(C'\fR, is arbitrary. We make
the match even more specific with the \f(CW:Args(0)\fR action modifier \*(--
this forces the match on \fIonly\fR \f(CW\*(C`/login\*(C'\fR, not
\&\f(CW\*(C`/login/somethingelse\*(C'\fR.
.PP
Next, update the corresponding method in
\&\f(CW\*(C`lib/MyApp/Controller/Logout.pm\*(C'\fR to match:
.PP
.Vb 1
\&    =head2 index
\&    
\&    Logout logic
\&    
\&    =cut
\&    
\&    sub index :Path :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Clear the user\*(Aqs state
\&        $c\->logout;
\&    
\&        # Send the user to the starting point
\&        $c\->response\->redirect($c\->uri_for(\*(Aq/\*(Aq));
\&    }
.Ve
.PP
As with the login controller, be sure to delete the
\&\f(CW\*(C`$c\->response\->body(\*(AqMatched MyApp::Controller::Logout in Logout.\*(Aq);\*(C'\fR
line of the \f(CW\*(C`sub index\*(C'\fR.
.SS "Add a Login Form \s-1TT\s0 Template Page"
.IX Subsection "Add a Login Form TT Template Page"
Create a login form by opening \f(CW\*(C`root/src/login.tt2\*(C'\fR and inserting:
.PP
.Vb 1
\&    [% META title = \*(AqLogin\*(Aq %]
\&    
\&    <!\-\- Login form \-\->
\&    <form method="post" action="[% c.uri_for(\*(Aq/login\*(Aq) %]">
\&      <table>
\&        <tr>
\&          <td>Username:</td>
\&          <td><input type="text" name="username" size="40" /></td>
\&        </tr>
\&        <tr>
\&          <td>Password:</td>
\&          <td><input type="password" name="password" size="40" /></td>
\&        </tr>
\&        <tr>
\&          <td colspan="2"><input type="submit" name="submit" value="Submit" /></td>
\&        </tr>
\&      </table>
\&    </form>
.Ve
.SS "Add Valid User Check"
.IX Subsection "Add Valid User Check"
We need something that provides enforcement for the authentication
mechanism \*(-- a \fIglobal\fR mechanism that prevents users who have not
passed authentication from reaching any pages except the login page.
This is generally done via an \f(CW\*(C`auto\*(C'\fR action/method in 
\&\f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR.
.PP
Edit the existing \f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR class file and insert
the following method:
.PP
.Vb 1
\&    =head2 auto
\&    
\&    Check if there is a user and, if not, forward to login page
\&    
\&    =cut
\&    
\&    # Note that \*(Aqauto\*(Aq runs after \*(Aqbegin\*(Aq but before your actions and that
\&    # \*(Aqauto\*(Aqs "chain" (all from application path to most specific class are run)
\&    # See the \*(AqActions\*(Aq section of \*(AqCatalyst::Manual::Intro\*(Aq for more info.
\&    sub auto :Private {
\&        my ($self, $c) = @_;
\&    
\&        # Allow unauthenticated users to reach the login page.  This
\&        # allows unauthenticated users to reach any action in the Login
\&        # controller.  To lock it down to a single action, we could use:
\&        #   if ($c\->action eq $c\->controller(\*(AqLogin\*(Aq)\->action_for(\*(Aqindex\*(Aq))
\&        # to only allow unauthenticated access to the \*(Aqindex\*(Aq action we
\&        # added above.
\&        if ($c\->controller eq $c\->controller(\*(AqLogin\*(Aq)) {
\&            return 1;
\&        }
\&    
\&        # If a user doesn\*(Aqt exist, force login
\&        if (!$c\->user_exists) {
\&            # Dump a log message to the development server debug output
\&            $c\->log\->debug(\*(Aq***Root::auto User not found, forwarding to /login\*(Aq);
\&            # Redirect the user to the login page
\&            $c\->response\->redirect($c\->uri_for(\*(Aq/login\*(Aq));
\&            # Return 0 to cancel \*(Aqpost\-auto\*(Aq processing and prevent use of application
\&            return 0;
\&        }
\&    
\&        # User found, so return 1 to continue with processing after this \*(Aqauto\*(Aq
\&        return 1;
\&    }
.Ve
.PP
As discussed in
\&\*(L"\s-1CREATE\s0 A \s-1CATALYST\s0 \s-1CONTROLLER\s0\*(R" in Catalyst::Manual::Tutorial::03_MoreCatalystBasics,
every \f(CW\*(C`auto\*(C'\fR method from the application/root controller down to the
most specific controller will be called.  By placing the
authentication enforcement code inside the \f(CW\*(C`auto\*(C'\fR method of
\&\f(CW\*(C`lib/MyApp/Controller/Root.pm\*(C'\fR (or \f(CW\*(C`lib/MyApp.pm\*(C'\fR), it will be
called for \fIevery\fR request that is received by the entire
application.
.SS "Displaying Content Only to Authenticated Users"
.IX Subsection "Displaying Content Only to Authenticated Users"
Let's say you want to provide some information on the login page that
changes depending on whether the user has authenticated yet.  To do
this, open \f(CW\*(C`root/src/login.tt2\*(C'\fR in your editor and add the following
lines to the bottom of the file:
.PP
.Vb 10
\&    ...
\&    <p>
\&    [%
\&       # This code illustrates how certain parts of the TT
\&       # template will only be shown to users who have logged in
\&    %]
\&    [% IF c.user_exists %]
\&        Please Note: You are already logged in as \*(Aq[% c.user.username %]\*(Aq.
\&        You can <a href="[% c.uri_for(\*(Aq/logout\*(Aq) %]">logout</a> here.
\&    [% ELSE %]
\&        You need to log in to use this application.
\&    [% END %]
\&    [%#
\&       Note that this whole block is a comment because the "#" appears
\&       immediate after the "[%" (with no spaces in between).  Although it
\&       can be a handy way to temporarily "comment out" a whole block of
\&       TT code, it\*(Aqs probably a little too subtle for use in "normal"
\&       comments.
\&    %]
\&    </p>
.Ve
.PP
Although most of the code is comments, the middle few lines provide a
\&\*(L"you are already logged in\*(R" reminder if the user returns to the login
page after they have already authenticated.  For users who have not yet
authenticated, a \*(L"You need to log in...\*(R" message is displayed (note the
use of an IF-THEN-ELSE construct in \s-1TT\s0).
.SS "Try Out Authentication"
.IX Subsection "Try Out Authentication"
The development server should have reloaded each time we edited one of 
the Controllers in the previous section. Now trying going to 
<http://localhost:3000/books/list> and you should be redirected to the 
login page, hitting Shift+Reload or Ctrl+Reload if necessary (the \*(L"You 
are already logged in\*(R" message should \fInot\fR appear \*(-- if it does, click 
the \f(CW\*(C`logout\*(C'\fR button and try again). Note the \f(CW\*(C`***Root::auto User not 
found...\*(C'\fR debug message in the development server output. Enter username 
\&\f(CW\*(C`test01\*(C'\fR and password \f(CW\*(C`mypass\*(C'\fR, and you should be taken to the Book 
List page.
.PP
\&\fB\s-1IMPORTANT\s0 \s-1NOTE:\s0\fR If you are having issues with authentication on
Internet Explorer, be sure to check the system clocks on both your
server and client machines.  Internet Explorer is very picky about
timestamps for cookies.  You can quickly sync a Debian system by
installing the \*(L"ntpdate\*(R" package:
.PP
.Vb 1
\&    sudo aptitude \-y install ntpdate
.Ve
.PP
And then run the following command:
.PP
.Vb 1
\&    sudo ntpdate\-debian
.Ve
.PP
Or, depending on your firewall configuration:
.PP
.Vb 1
\&    sudo ntpdate\-debian \-u
.Ve
.PP
Note: \s-1NTP\s0 can be a little more finicky about firewalls because it uses
\&\s-1UDP\s0 vs. the more common \s-1TCP\s0 that you see with most Internet protocols.
Worse case, you might have to manually set the time on your development
box instead of using \s-1NTP\s0.
.PP
Open \f(CW\*(C`root/src/books/list.tt2\*(C'\fR and add the following lines to the
bottom (below the closing </table> tag):
.PP
.Vb 5
\&    ...
\&    <p>
\&      <a href="[% c.uri_for(\*(Aq/login\*(Aq) %]">Login</a>
\&      <a href="[% c.uri_for(c.controller.action_for(\*(Aqform_create\*(Aq)) %]">Create</a>
\&    </p>
.Ve
.PP
Reload your browser and you should now see a \*(L"Login\*(R" and \*(L"Create\*(R" links
at the bottom of the page (as mentioned earlier, you can update template
files without a development server reload).  Click the first link
to return to the login page.  This time you \fIshould\fR see the \*(L"You are
already logged in\*(R" message.
.PP
Finally, click the \f(CW\*(C`You can logout here\*(C'\fR link on the \f(CW\*(C`/login\*(C'\fR page.
You should stay at the login page, but the message should change to \*(L"You
need to log in to use this application.\*(R"
.SH "USING PASSWORD HASHES"
.IX Header "USING PASSWORD HASHES"
In this section we increase the security of our system by converting 
from cleartext passwords to \s-1SHA\-1\s0 password hashes that include a 
random \*(L"salt\*(R" value to make them extremely difficult to crack with
dictionary and \*(L"rainbow table\*(R" attacks.
.PP
\&\fBNote:\fR This section is optional.  You can skip it and the rest of the
tutorial will function normally.
.PP
Be aware that even with the techniques shown in this section, the browser
still transmits the passwords in cleartext to your application.  We are
just avoiding the \fIstorage\fR of cleartext passwords in the database by
using a salted \s-1SHA\-1\s0 hash. If you are concerned about cleartext passwords
between the browser and your application, consider using \s-1SSL/TLS\s0, made
easy with the Catalyst plugin Catalyst::Plugin:RequireSSL.
.SS "Re-Run the DBIC::Schema Model Helper to Include DBIx::Class::EncodedColumn"
.IX Subsection "Re-Run the DBIC::Schema Model Helper to Include DBIx::Class::EncodedColumn"
Next, we can re-run the model helper to have it include 
DBIx::Class::EncodedColumn in all of the 
Result Classes it generates for us.  Simply use the same command we 
saw in Chapters 3 and 4, but add \f(CW\*(C`,EncodedColumn\*(C'\fR to the \f(CW\*(C`components\*(C'\fR
argument:
.PP
.Vb 3
\&    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \e
\&        create=static components=TimeStamp,EncodedColumn dbi:SQLite:myapp.db \e
\&        on_connect_do="PRAGMA foreign_keys = ON"
.Ve
.PP
If you then open one of the Result Classes, you will see that it 
includes EncodedColumn in the \f(CW\*(C`load_components\*(C'\fR line.  Take a look at 
\&\f(CW\*(C`lib/MyApp/Schema/Result/User.pm\*(C'\fR since that's the main class where we
want to use hashed and salted passwords:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->load_components("InflateColumn::DateTime", "TimeStamp", "EncodedColumn");
.Ve
.ie n .SS "Modify the ""password"" Column to Use EncodedColumn"
.el .SS "Modify the ``password'' Column to Use EncodedColumn"
.IX Subsection "Modify the password Column to Use EncodedColumn"
Open the file \f(CW\*(C`lib/MyApp/Schema/Result/User.pm\*(C'\fR and enter the following
text below the \*(L"# \s-1DO\s0 \s-1NOT\s0 \s-1MODIFY\s0 \s-1THIS\s0 \s-1OR\s0 \s-1ANYTHING\s0 \s-1ABOVE\s0!\*(R" line but above
the closing \*(L"1;\*(R":
.PP
.Vb 12
\&    # Have the \*(Aqpassword\*(Aq column use a SHA\-1 hash and 10\-character salt
\&    # with hex encoding; Generate the \*(Aqcheck_password" method
\&    _\|_PACKAGE_\|_\->add_columns(
\&        \*(Aqpassword\*(Aq => {
\&            data_type           => "TEXT",
\&            size                => undef,
\&            encode_column       => 1,
\&            encode_class        => \*(AqDigest\*(Aq,
\&            encode_args         => {salt_length => 10},
\&            encode_check_method => \*(Aqcheck_password\*(Aq,
\&        },
\&    );
.Ve
.PP
This redefines the automatically generated definition for the password 
fields at the top of the Result Class file to now use EncodedColumn 
logic (\f(CW\*(C`encoded_column\*(C'\fR is set to 1).  \f(CW\*(C`encode_class\*(C'\fR can be set to 
either \f(CW\*(C`Digest\*(C'\fR to use 
DBIx::Class::EncodedColumn::Digest, 
or \f(CW\*(C`Crypt::Eksblowfish::Bcrypt\*(C'\fR for 
DBIx::Class::EncodedColumn::Crypt::Eksblowfish::Bcrypt.
\&\f(CW\*(C`encode_args\*(C'\fR is then used to customize the type of Digest you 
selected. Here we only specified the size of the salt to use, but
we could have also modified the hashing algorithm ('\s-1SHA\-256\s0' is 
the default) and the format to use ('base64' is the default, but
\&'hex' and 'binary' are other options).  To use these, you could 
change the \f(CW\*(C`encode_args\*(C'\fR to something like:
.PP
.Vb 3
\&            encode_args         => {algorithm => \*(AqSHA\-1\*(Aq, 
\&                                    format => \*(Aqhex\*(Aq, 
\&                                    salt_length => 10},
.Ve
.SS "Load Hashed Passwords in the Database"
.IX Subsection "Load Hashed Passwords in the Database"
Next, let's create a quick script to load some hashed and salted passwords
into the \f(CW\*(C`password\*(C'\fR column of our \f(CW\*(C`users\*(C'\fR table.  Open the file
\&\f(CW\*(C`set_hashed_passwords.pl\*(C'\fR in your editor and enter the following text:
.PP
.Vb 1
\&    #!/usr/bin/perl
\&    
\&    use strict;
\&    use warnings;
\&    
\&    use MyApp::Schema;
\&    
\&    my $schema = MyApp::Schema\->connect(\*(Aqdbi:SQLite:myapp.db\*(Aq);
\&    
\&    my @users = $schema\->resultset(\*(AqUser\*(Aq)\->all;
\&    
\&    foreach my $user (@users) {
\&        $user\->password(\*(Aqmypass\*(Aq);
\&        $user\->update;
\&    }
.Ve
.PP
EncodedColumn lets us simple call \f(CW\*(C`$user\-\*(C'\fRcheck_password($password)> 
to see if the user has supplied the correct password, or, as we show 
above, call \f(CW\*(C`$user\-\*(C'\fRupdate($new_password)> to update the hashed 
password stored for this user.
.PP
Then run the following command:
.PP
.Vb 1
\&    $ DBIC_TRACE=1 perl \-Ilib set_hashed_passwords.pl
.Ve
.PP
We had to use the \f(CW\*(C`\-Ilib\*(C'\fR argument to tell perl to look under the 
\&\f(CW\*(C`lib\*(C'\fR directory for our \f(CW\*(C`MyApp::Schema\*(C'\fR model.
.PP
The \s-1DBIC_TRACE\s0 output should show that the update worked:
.PP
.Vb 9
\&    $ DBIC_TRACE=1 perl \-Ilib set_hashed_passwords.pl
\&    SELECT me.id, me.username, me.password, me.email_address, 
\&    me.first_name, me.last_name, me.active FROM user me: 
\&    UPDATE user SET password = ? WHERE ( id = ? ): 
\&    \*(AqoXiyAcGOjowz7ISUhpIm1IrS8AxSZ9r4jNjpX9VnVeQmN6GRtRKTz\*(Aq, \*(Aq1\*(Aq
\&    UPDATE user SET password = ? WHERE ( id = ? ): 
\&    \*(AqPmyEPrkB8EGwvaF/DvJm7LIfxoZARjv8ygFIR7pc1gEA1OfwHGNzs\*(Aq, \*(Aq2\*(Aq
\&    UPDATE user SET password = ? WHERE ( id = ? ): 
\&    \*(Aqh7CS1Fm9UCs4hjcbu2im0HumaHCJUq4Uriac+SQgdUMUfFSoOrz3c\*(Aq, \*(Aq3\*(Aq
.Ve
.PP
But we can further confirm our actions by dumping the users table:
.PP
.Vb 4
\&    $ sqlite3 myapp.db "select * from user"
\&    1|test01|38d3974fa9e9263099f7bc2574284b2f55473a9bM=fwpX2NR8|t01@na.com|Joe|Blow|1
\&    2|test02|6ed8586587e53e0d7509b1cfed5df08feadc68cbMJlnPyPt0I|t02@na.com|Jane|Doe|1
\&    3|test03|af929a151340c6aed4d54d7e2651795d1ad2e2f7UW8dHoGv9z|t03@na.com|No|Go|0
.Ve
.PP
As you can see, the passwords are much harder to steal from the 
database (not only are the hashes stored, but every hash is different 
even though the passwords are the same because of the added \*(L"salt\*(R" 
value).  Also note that this demonstrates how to use a DBIx::Class 
model outside of your web application \*(-- a very useful feature in many 
situations.
.SS "Enable Hashed and Salted Passwords"
.IX Subsection "Enable Hashed and Salted Passwords"
Edit \f(CW\*(C`lib/MyApp.pm\*(C'\fR and update it to match the following text (the 
only change is to the \f(CW\*(C`password_type\*(C'\fR field):
.PP
.Vb 8
\&    # Configure SimpleDB Authentication
\&    _\|_PACKAGE_\|_\->config\->{\*(AqPlugin::Authentication\*(Aq} = {
\&            default => {
\&                class           => \*(AqSimpleDB\*(Aq,
\&                user_model      => \*(AqDB::User\*(Aq,
\&                password_type   => \*(Aqself_check\*(Aq,
\&            },
\&        };
.Ve
.PP
The use of \f(CW\*(C`self_check\*(C'\fR will cause 
Catalyst::Plugin::Authentication::Store::DBIC to call the 
\&\f(CW\*(C`check_password\*(C'\fR method we enabled on our \f(CW\*(C`password\*(C'\fR columns.
.SS "Try Out the Hashed Passwords"
.IX Subsection "Try Out the Hashed Passwords"
The development server should restart as soon as your save the 
\&\f(CW\*(C`lib/MyApp.pm\*(C'\fR file in the previous section. You should now be able to 
go to <http://localhost:3000/books/list> and login as before. When 
done, click the \*(L"logout\*(R" link on the login page (or point your browser 
at <http://localhost:3000/logout>).
.SH "USING THE SESSION FOR FLASH"
.IX Header "USING THE SESSION FOR FLASH"
As discussed in the previous chapter of the tutorial, \f(CW\*(C`flash\*(C'\fR allows 
you to set variables in a way that is very similar to \f(CW\*(C`stash\*(C'\fR, but it 
will remain set across multiple requests.  Once the value is read, it 
is cleared (unless reset).  Although \f(CW\*(C`flash\*(C'\fR has nothing to do with 
authentication, it does leverage the same session plugins.  Now that 
those plugins are enabled, let's go back and update the \*(L"delete and 
redirect with query parameters\*(R" code seen at the end of the Basic 
\&\s-1CRUD\s0 chapter of the tutorial to 
take advantage of \f(CW\*(C`flash\*(C'\fR.
.PP
First, open \f(CW\*(C`lib/MyApp/Controller/Books.pm\*(C'\fR and modify \f(CW\*(C`sub delete\*(C'\fR
to match the following (everything after the model search line of code
has changed):
.PP
.Vb 1
\&    =head2 delete
\&    
\&    Delete a book
\&    
\&    =cut
\&    
\&    sub delete :Chained(\*(Aqobject\*(Aq) :PathPart(\*(Aqdelete\*(Aq) :Args(0) {
\&        my ($self, $c) = @_;
\&    
\&        # Use the book object saved by \*(Aqobject\*(Aq and delete it along
\&        # with related \*(Aqbook_authors\*(Aq entries
\&        $c\->stash\->{object}\->delete;
\&    
\&        # Use \*(Aqflash\*(Aq to save information across requests until it\*(Aqs read
\&        $c\->flash\->{status_msg} = "Book deleted";
\&    
\&        # Redirect the user back to the list page
\&        $c\->response\->redirect($c\->uri_for($self\->action_for(\*(Aqlist\*(Aq)));
\&    }
.Ve
.PP
Next, open \f(CW\*(C`root/src/wrapper.tt2\*(C'\fR and update the \s-1TT\s0 code to pull from
flash vs. the \f(CW\*(C`status_msg\*(C'\fR query parameter:
.PP
.Vb 9
\&    ...
\&    <div id="content">
\&        [%# Status and error messages %]
\&        <span class="message">[% status_msg || c.flash.status_msg %]</span>
\&        <span class="error">[% error_msg %]</span>
\&        [%# This is where TT will stick all of your template\*(Aqs contents. \-%]
\&        [% content %]
\&    </div><!\-\- end content \-\->
\&    ...
.Ve
.PP
Although the sample above only shows the \f(CW\*(C`content\*(C'\fR div, leave the
rest of the file intact \*(-- the only change we made to replace 
\&\*(L"|| c.request.params.status_msg\*(R" with \*(L"c.flash.status_msg\*(R" in the 
\&\f(CW\*(C`<span class="message">\*(C'\fR line.
.SS "Try Out Flash"
.IX Subsection "Try Out Flash"
Authenticate using the login screen and then point your browser to
<http://localhost:3000/books/url_create/Test/1/4> to create an extra
several books.  Click the \*(L"Return to list\*(R" link and delete one of the
\&\*(L"Test\*(R" books you just added.  The \f(CW\*(C`flash\*(C'\fR mechanism should retain our
\&\*(L"Book deleted\*(R" status message across the redirect.
.PP
\&\fB\s-1NOTE:\s0\fR While \f(CW\*(C`flash\*(C'\fR will save information across multiple requests,
\&\fIit does get cleared the first time it is read\fR.  In general, this is
exactly what you want \*(-- the \f(CW\*(C`flash\*(C'\fR message will get displayed on
the next screen where it's appropriate, but it won't \*(L"keep showing up\*(R"
after that first time (unless you reset it).  Please refer to
Catalyst::Plugin::Session for additional
information.
.SS "Switch To Flash-To-Stash"
.IX Subsection "Switch To Flash-To-Stash"
Although the a use of flash above works well, the
\&\f(CW\*(C`status_msg || c.flash.status_msg\*(C'\fR statement is a little ugly. A nice
alternative is to use the \f(CW\*(C`flash_to_stash\*(C'\fR feature that automatically
copies the content of flash to stash.  This makes your controller
and template code work regardless of where it was directly access, a
forward, or a redirect.  To enable \f(CW\*(C`flash_to_stash\*(C'\fR, you can either
set the value in \f(CW\*(C`lib/MyApp.pm\*(C'\fR by changing the default
\&\f(CW\*(C`_\|_PACKAGE_\|_\->config\*(C'\fR setting to something like:
.PP
.Vb 6
\&    _\|_PACKAGE_\|_\->config(
\&            name    => \*(AqMyApp\*(Aq,
\&            # Disable deprecated behavior needed by old applications
\&            disable_component_resolution_regex_fallback => 1,
\&            session => { flash_to_stash => 1 },
\&        );
.Ve
.PP
\&\fBor\fR add the following to \f(CW\*(C`myapp.conf\*(C'\fR:
.PP
.Vb 3
\&    <session>
\&        flash_to_stash   1
\&    </session>
.Ve
.PP
The \f(CW\*(C`_\|_PACKAGE_\|_\->config\*(C'\fR option is probably preferable here
since it's not something you will want to change at runtime without it
possibly breaking some of your code.
.PP
Then edit \f(CW\*(C`root/src/wrapper.tt2\*(C'\fR and change the \f(CW\*(C`status_msg\*(C'\fR line
to match the following:
.PP
.Vb 1
\&    <span class="message">[% status_msg %]</span>
.Ve
.PP
Now go to <http://localhost:3000/books/list> in your browser. Delete 
another of the \*(L"Test\*(R" books you added in the previous step. Flash should 
still maintain the status message across the redirect even though you 
are no longer explicitly accessing \f(CW\*(C`c.flash\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kennedy Clark, \f(CW\*(C`hkclark@gmail.com\*(C'\fR
.PP
Please report any errors, issues or suggestions to the author.  The
most recent version of the Catalyst Tutorial can be found at
http://dev.catalyst.perl.org/repos/Catalyst/Catalyst\-Manual/5.80/trunk/lib/Catalyst/Manual/Tutorial/ <http://dev.catalyst.perl.org/repos/Catalyst/Catalyst-Manual/5.80/trunk/lib/Catalyst/Manual/Tutorial/>.
.PP
Copyright 2006\-2008, Kennedy Clark, under Creative Commons License
(http://creativecommons.org/licenses/by\-sa/3.0/us/ <http://creativecommons.org/licenses/by-sa/3.0/us/>).
