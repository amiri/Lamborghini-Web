.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Engine::CGI 3"
.TH Catalyst::Engine::CGI 3 "2010-07-28" "perl v5.12.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Engine::CGI \- The CGI Engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A script using the Catalyst::Engine::CGI module might look like:
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    use strict;
\&    use lib \*(Aq/path/to/MyApp/lib\*(Aq;
\&    use MyApp;
\&
\&    MyApp\->run;
.Ve
.PP
The application module (\f(CW\*(C`MyApp\*(C'\fR) would use \f(CW\*(C`Catalyst\*(C'\fR, which loads the
appropriate engine module.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the Catalyst engine specialized for the \s-1CGI\s0 environment.
.SH "PATH DECODING"
.IX Header "PATH DECODING"
Most web server environments pass the requested path to the application using environment variables,
from which Catalyst has to reconstruct the request base (i.e. the top level path to / in the application,
exposed as \f(CW\*(C`$c\->request\->base\*(C'\fR) and the request path below that base.
.PP
There are two methods of doing this, both of which have advantages and disadvantages. Which method is used
is determined by the \f(CW\*(C`$c\->config(use_request_uri_for_path)\*(C'\fR setting (which can either be true or false).
.SS "use_request_uri_for_path => 0"
.IX Subsection "use_request_uri_for_path => 0"
This is the default (and the) traditional method that Catalyst has used for determining the path information.
The path is synthesised from a combination of the \f(CW\*(C`PATH_INFO\*(C'\fR and \f(CW\*(C`SCRIPT_NAME\*(C'\fR environment variables.
The allows the application to behave correctly when \f(CW\*(C`mod_rewrite\*(C'\fR is being used to redirect requests
into the application, as these variables are adjusted by mod_rewrite to take account for the redirect.
.PP
However this method has the major disadvantage that it is impossible to correctly decode some elements
of the path, as \s-1RFC\s0 3875 says: "\f(CW\*(C`Unlike a URI path, the PATH_INFO is not URL\-encoded, and cannot
contain path\-segment parameters.\*(C'\fR" This means \s-1PATH_INFO\s0 is \fBalways\fR decoded, and therefore Catalyst
can't distinguish / vs \f(CW%2F\fR in paths (in addition to other encoded values).
.SS "use_request_uri_for_path => 1"
.IX Subsection "use_request_uri_for_path => 1"
This method uses the \f(CW\*(C`REQUEST_URI\*(C'\fR and \f(CW\*(C`SCRIPT_NAME\*(C'\fR environment variables. As \f(CW\*(C`REQUEST_URI\*(C'\fR is never
decoded, this means that applications using this mode can correctly handle URIs including the \f(CW%2F\fR character
(i.e. with \f(CW\*(C`AllowEncodedSlashes\*(C'\fR set to \f(CW\*(C`On\*(C'\fR in Apache).
.PP
Given that this method of path resolution is provably more correct, it is recommended that you use
this unless you have a specific need to deploy your application in a non-standard environment, and you are
aware of the implications of not being able to handle encoded \s-1URI\s0 paths correctly.
.PP
However it also means that in a number of cases when the app isn't installed directly at a path, but instead
is having paths rewritten into it (e.g. as a .cgi/fcgi in a public_html directory, with mod_rewrite in a
\&.htaccess file, or when \s-1SSI\s0 is used to rewrite pages into the app, or when sub-paths of the app are exposed
at other URIs than that which the app is 'normally' based at with \f(CW\*(C`mod_rewrite\*(C'\fR), the resolution of
\&\f(CW\*(C`$c\->request\->base\*(C'\fR will be incorrect.
.SH "OVERLOADED METHODS"
.IX Header "OVERLOADED METHODS"
This class overloads some methods from \f(CW\*(C`Catalyst::Engine\*(C'\fR.
.ie n .SS "$self\->finalize_headers($c)"
.el .SS "\f(CW$self\fP\->finalize_headers($c)"
.IX Subsection "$self->finalize_headers($c)"
.ie n .SS "$self\->prepare_connection($c)"
.el .SS "\f(CW$self\fP\->prepare_connection($c)"
.IX Subsection "$self->prepare_connection($c)"
.ie n .SS "$self\->prepare_headers($c)"
.el .SS "\f(CW$self\fP\->prepare_headers($c)"
.IX Subsection "$self->prepare_headers($c)"
.ie n .SS "$self\->prepare_path($c)"
.el .SS "\f(CW$self\fP\->prepare_path($c)"
.IX Subsection "$self->prepare_path($c)"
.ie n .SS "$self\->prepare_query_parameters($c)"
.el .SS "\f(CW$self\fP\->prepare_query_parameters($c)"
.IX Subsection "$self->prepare_query_parameters($c)"
.ie n .SS "$self\->prepare_request($c, (env => \e%env))"
.el .SS "\f(CW$self\fP\->prepare_request($c, (env => \e%env))"
.IX Subsection "$self->prepare_request($c, (env => %env))"
.ie n .SS "$self\->prepare_write($c)"
.el .SS "\f(CW$self\fP\->prepare_write($c)"
.IX Subsection "$self->prepare_write($c)"
Enable autoflush on the output handle for CGI-based engines.
.ie n .SS "$self\->write($c, $buffer)"
.el .SS "\f(CW$self\fP\->write($c, \f(CW$buffer\fP)"
.IX Subsection "$self->write($c, $buffer)"
Writes the buffer to the client.
.ie n .SS "$self\->read_chunk($c, $buffer, $length)"
.el .SS "\f(CW$self\fP\->read_chunk($c, \f(CW$buffer\fP, \f(CW$length\fP)"
.IX Subsection "$self->read_chunk($c, $buffer, $length)"
.ie n .SS "$self\->run"
.el .SS "\f(CW$self\fP\->run"
.IX Subsection "$self->run"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst, Catalyst::Engine
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
