.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Relationship::Base 3"
.TH DBIx::Class::Relationship::Base 3 "2010-06-03" "perl v5.12.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Relationship::Base \- Inter\-table relationships
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides methods to describe the relationships between the
tables in your database model. These are the \*(L"bare bones\*(R" relationships
methods, for predefined ones, look in DBIx::Class::Relationship.
.SH "METHODS"
.IX Header "METHODS"
.SS "add_relationship"
.IX Subsection "add_relationship"
.ie n .IP "Arguments: 'relname', 'Foreign::Class', $cond, $attrs" 4
.el .IP "Arguments: 'relname', 'Foreign::Class', \f(CW$cond\fR, \f(CW$attrs\fR" 4
.IX Item "Arguments: 'relname', 'Foreign::Class', $cond, $attrs"
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->add_relationship(\*(Aqrelname\*(Aq, \*(AqForeign::Class\*(Aq, $cond, $attrs);
.Ve
.PP
\fIcondition\fR
.IX Subsection "condition"
.PP
The condition needs to be an SQL::Abstract\-style representation of the
join between the tables. When resolving the condition for use in a \f(CW\*(C`JOIN\*(C'\fR,
keys using the pseudo-table \f(CW\*(C`foreign\*(C'\fR are resolved to mean \*(L"the Table on the
other side of the relationship\*(R", and values using the pseudo-table \f(CW\*(C`self\*(C'\fR
are resolved to mean \*(L"the Table this class is representing\*(R". Other
restrictions, such as by value, sub-select and other tables, may also be
used. Please check your database for \f(CW\*(C`JOIN\*(C'\fR parameter support.
.PP
For example, if you're creating a relationship from \f(CW\*(C`Author\*(C'\fR to \f(CW\*(C`Book\*(C'\fR, where
the \f(CW\*(C`Book\*(C'\fR table has a column \f(CW\*(C`author_id\*(C'\fR containing the \s-1ID\s0 of the \f(CW\*(C`Author\*(C'\fR
row:
.PP
.Vb 1
\&  { \*(Aqforeign.author_id\*(Aq => \*(Aqself.id\*(Aq }
.Ve
.PP
will result in the \f(CW\*(C`JOIN\*(C'\fR clause
.PP
.Vb 1
\&  author me JOIN book book ON book.author_id = me.id
.Ve
.PP
For multi-column foreign keys, you will need to specify a \f(CW\*(C`foreign\*(C'\fR\-to\-\f(CW\*(C`self\*(C'\fR
mapping for each column in the key. For example, if you're creating a
relationship from \f(CW\*(C`Book\*(C'\fR to \f(CW\*(C`Edition\*(C'\fR, where the \f(CW\*(C`Edition\*(C'\fR table refers to a
publisher and a type (e.g. \*(L"paperback\*(R"):
.PP
.Vb 4
\&  {
\&    \*(Aqforeign.publisher_id\*(Aq => \*(Aqself.publisher_id\*(Aq,
\&    \*(Aqforeign.type_id\*(Aq      => \*(Aqself.type_id\*(Aq,
\&  }
.Ve
.PP
This will result in the \f(CW\*(C`JOIN\*(C'\fR clause:
.PP
.Vb 2
\&  book me JOIN edition edition ON edition.publisher_id = me.publisher_id
\&    AND edition.type_id = me.type_id
.Ve
.PP
Each key-value pair provided in a hashref will be used as \f(CW\*(C`AND\*(C'\fRed conditions.
To add an \f(CW\*(C`OR\*(C'\fRed condition, use an arrayref of hashrefs. See the
SQL::Abstract documentation for more details.
.PP
\fIattributes\fR
.IX Subsection "attributes"
.PP
The standard ResultSet attributes may
be used as relationship attributes. In particular, the 'where' attribute is
useful for filtering relationships:
.PP
.Vb 4
\&     _\|_PACKAGE_\|_\->has_many( \*(Aqvalid_users\*(Aq, \*(AqMyApp::Schema::User\*(Aq,
\&        { \*(Aqforeign.user_id\*(Aq => \*(Aqself.user_id\*(Aq },
\&        { where => { valid => 1 } }
\&    );
.Ve
.PP
The following attributes are also valid:
.IP "join_type" 4
.IX Item "join_type"
Explicitly specifies the type of join to use in the relationship. Any \s-1SQL\s0
join type is valid, e.g. \f(CW\*(C`LEFT\*(C'\fR or \f(CW\*(C`RIGHT\*(C'\fR. It will be placed in the \s-1SQL\s0
command immediately before \f(CW\*(C`JOIN\*(C'\fR.
.IP "proxy" 4
.IX Item "proxy"
An arrayref containing a list of accessors in the foreign class to create in
the main class. If, for example, you do the following:
.Sp
.Vb 4
\&  MyDB::Schema::CD\->might_have(liner_notes => \*(AqMyDB::Schema::LinerNotes\*(Aq,
\&    undef, {
\&      proxy => [ qw/notes/ ],
\&    });
.Ve
.Sp
Then, assuming MyDB::Schema::LinerNotes has an accessor named notes, you can do:
.Sp
.Vb 3
\&  my $cd = MyDB::Schema::CD\->find(1);
\&  $cd\->notes(\*(AqNotes go here\*(Aq); # set notes \-\- LinerNotes object is
\&                               # created if it doesn\*(Aqt exist
.Ve
.IP "accessor" 4
.IX Item "accessor"
Specifies the type of accessor that should be created for the relationship.
Valid values are \f(CW\*(C`single\*(C'\fR (for when there is only a single related object),
\&\f(CW\*(C`multi\*(C'\fR (when there can be many), and \f(CW\*(C`filter\*(C'\fR (for when there is a single
related object, but you also want the relationship accessor to double as
a column accessor). For \f(CW\*(C`multi\*(C'\fR accessors, an add_to_* method is also
created, which calls \f(CW\*(C`create_related\*(C'\fR for the relationship.
.IP "is_foreign_key_constraint" 4
.IX Item "is_foreign_key_constraint"
If you are using SQL::Translator to create \s-1SQL\s0 for you and you find that it
is creating constraints where it shouldn't, or not creating them where it
should, set this attribute to a true or false value to override the detection
of when to create constraints.
.IP "cascade_copy" 4
.IX Item "cascade_copy"
If \f(CW\*(C`cascade_copy\*(C'\fR is true on a \f(CW\*(C`has_many\*(C'\fR relationship for an
object, then when you copy the object all the related objects will
be copied too. To turn this behaviour off, pass \f(CW\*(C`cascade_copy => 0\*(C'\fR
in the \f(CW$attr\fR hashref.
.Sp
The behaviour defaults to \f(CW\*(C`cascade_copy => 1\*(C'\fR for \f(CW\*(C`has_many\*(C'\fR
relationships.
.IP "cascade_delete" 4
.IX Item "cascade_delete"
By default, DBIx::Class cascades deletes across \f(CW\*(C`has_many\*(C'\fR,
\&\f(CW\*(C`has_one\*(C'\fR and \f(CW\*(C`might_have\*(C'\fR relationships. You can disable this
behaviour on a per-relationship basis by supplying
\&\f(CW\*(C`cascade_delete => 0\*(C'\fR in the relationship attributes.
.Sp
The cascaded operations are performed after the requested delete,
so if your database has a constraint on the relationship, it will
have deleted/updated the related records or raised an exception
before DBIx::Class gets to perform the cascaded operation.
.IP "cascade_update" 4
.IX Item "cascade_update"
By default, DBIx::Class cascades updates across \f(CW\*(C`has_one\*(C'\fR and
\&\f(CW\*(C`might_have\*(C'\fR relationships. You can disable this behaviour on a
per-relationship basis by supplying \f(CW\*(C`cascade_update => 0\*(C'\fR in
the relationship attributes.
.Sp
This is not a \s-1RDMS\s0 style cascade update \- it purely means that when
an object has update called on it, all the related objects also
have update called. It will not change foreign keys automatically \-
you must arrange to do this yourself.
.IP "on_delete / on_update" 4
.IX Item "on_delete / on_update"
If you are using SQL::Translator to create \s-1SQL\s0 for you, you can use these
attributes to explicitly set the desired \f(CW\*(C`ON DELETE\*(C'\fR or \f(CW\*(C`ON UPDATE\*(C'\fR constraint
type. If not supplied the \s-1SQLT\s0 parser will attempt to infer the constraint type by
interrogating the attributes of the \fBopposite\fR relationship. For any 'multi'
relationship with \f(CW\*(C`cascade_delete => 1\*(C'\fR, the corresponding belongs_to
relationship will be created with an \f(CW\*(C`ON DELETE CASCADE\*(C'\fR constraint. For any
relationship bearing \f(CW\*(C`cascade_copy => 1\*(C'\fR the resulting belongs_to constraint
will be \f(CW\*(C`ON UPDATE CASCADE\*(C'\fR. If you wish to disable this autodetection, and just
use the \s-1RDBMS\s0' default constraint type, pass \f(CW\*(C`on_delete => undef\*(C'\fR or
\&\f(CW\*(C`on_delete => \*(Aq\*(Aq\*(C'\fR, and the same for \f(CW\*(C`on_update\*(C'\fR respectively.
.IP "is_deferrable" 4
.IX Item "is_deferrable"
Tells SQL::Translator that the foreign key constraint it creates should be
deferrable. In other words, the user may request that the constraint be ignored
until the end of the transaction. Currently, only the PostgreSQL producer
actually supports this.
.IP "add_fk_index" 4
.IX Item "add_fk_index"
Tells SQL::Translator to add an index for this constraint. Can also be
specified globally in the args to \*(L"deploy\*(R" in DBIx::Class::Schema or
\&\*(L"create_ddl_dir\*(R" in DBIx::Class::Schema. Default is on, set to 0 to disable.
.SS "register_relationship"
.IX Subsection "register_relationship"
.ie n .IP "Arguments: $relname, $rel_info" 4
.el .IP "Arguments: \f(CW$relname\fR, \f(CW$rel_info\fR" 4
.IX Item "Arguments: $relname, $rel_info"
.PP
Registers a relationship on the class. This is called internally by
DBIx::Class::ResultSourceProxy to set up Accessors and Proxies.
.SS "related_resultset"
.IX Subsection "related_resultset"
.ie n .IP "Arguments: $relationship_name" 4
.el .IP "Arguments: \f(CW$relationship_name\fR" 4
.IX Item "Arguments: $relationship_name"
.PD 0
.ie n .IP "Return Value: $related_resultset" 4
.el .IP "Return Value: \f(CW$related_resultset\fR" 4
.IX Item "Return Value: $related_resultset"
.PD
.PP
.Vb 1
\&  $rs = $cd\->related_resultset(\*(Aqartist\*(Aq);
.Ve
.PP
Returns a DBIx::Class::ResultSet for the relationship named
\&\f(CW$relationship_name\fR.
.SS "search_related"
.IX Subsection "search_related"
.Vb 2
\&  @objects = $rs\->search_related(\*(Aqrelname\*(Aq, $cond, $attrs);
\&  $objects_rs = $rs\->search_related(\*(Aqrelname\*(Aq, $cond, $attrs);
.Ve
.PP
Run a search on a related resultset. The search will be restricted to the
item or items represented by the DBIx::Class::ResultSet it was called
upon. This method can be called on a ResultSet, a Row or a ResultSource class.
.SS "search_related_rs"
.IX Subsection "search_related_rs"
.Vb 1
\&  ( $objects_rs ) = $rs\->search_related_rs(\*(Aqrelname\*(Aq, $cond, $attrs);
.Ve
.PP
This method works exactly the same as search_related, except that
it guarantees a resultset, even in list context.
.SS "count_related"
.IX Subsection "count_related"
.Vb 1
\&  $obj\->count_related(\*(Aqrelname\*(Aq, $cond, $attrs);
.Ve
.PP
Returns the count of all the items in the related resultset, restricted by the
current item or where conditions. Can be called on a
\&\*(L"ResultSet\*(R" in DBIx::Class::Manual::Glossary or a
\&\*(L"Row\*(R" in DBIx::Class::Manual::Glossary object.
.SS "new_related"
.IX Subsection "new_related"
.Vb 1
\&  my $new_obj = $obj\->new_related(\*(Aqrelname\*(Aq, \e%col_data);
.Ve
.PP
Create a new item of the related foreign class. If called on a
Row object, it will magically
set any foreign key columns of the new object to the related primary
key columns of the source object for you.  The newly created item will
not be saved into your storage until you call \*(L"insert\*(R" in DBIx::Class::Row
on it.
.SS "create_related"
.IX Subsection "create_related"
.Vb 1
\&  my $new_obj = $obj\->create_related(\*(Aqrelname\*(Aq, \e%col_data);
.Ve
.PP
Creates a new item, similarly to new_related, and also inserts the item's data
into your storage medium. See the distinction between \f(CW\*(C`create\*(C'\fR and \f(CW\*(C`new\*(C'\fR
in DBIx::Class::ResultSet for details.
.SS "find_related"
.IX Subsection "find_related"
.Vb 1
\&  my $found_item = $obj\->find_related(\*(Aqrelname\*(Aq, @pri_vals | \e%pri_vals);
.Ve
.PP
Attempt to find a related object using its primary key or unique constraints.
See \*(L"find\*(R" in DBIx::Class::ResultSet for details.
.SS "find_or_new_related"
.IX Subsection "find_or_new_related"
.Vb 1
\&  my $new_obj = $obj\->find_or_new_related(\*(Aqrelname\*(Aq, \e%col_data);
.Ve
.PP
Find an item of a related class. If none exists, instantiate a new item of the
related class. The object will not be saved into your storage until you call
\&\*(L"insert\*(R" in DBIx::Class::Row on it.
.SS "find_or_create_related"
.IX Subsection "find_or_create_related"
.Vb 1
\&  my $new_obj = $obj\->find_or_create_related(\*(Aqrelname\*(Aq, \e%col_data);
.Ve
.PP
Find or create an item of a related class. See
\&\*(L"find_or_create\*(R" in DBIx::Class::ResultSet for details.
.SS "update_or_create_related"
.IX Subsection "update_or_create_related"
.Vb 1
\&  my $updated_item = $obj\->update_or_create_related(\*(Aqrelname\*(Aq, \e%col_data, \e%attrs?);
.Ve
.PP
Update or create an item of a related class. See
\&\*(L"update_or_create\*(R" in DBIx::Class::ResultSet for details.
.SS "set_from_related"
.IX Subsection "set_from_related"
.Vb 2
\&  $book\->set_from_related(\*(Aqauthor\*(Aq, $author_obj);
\&  $book\->author($author_obj);                      ## same thing
.Ve
.PP
Set column values on the current object, using related values from the given
related object. This is used to associate previously separate objects, for
example, to set the correct author for a book, find the Author object, then
call set_from_related on the book.
.PP
This is called internally when you pass existing objects as values to
\&\*(L"create\*(R" in DBIx::Class::ResultSet, or pass an object to a belongs_to accessor.
.PP
The columns are only set in the local copy of the object, call \*(L"update\*(R" to
set them in the storage.
.SS "update_from_related"
.IX Subsection "update_from_related"
.Vb 1
\&  $book\->update_from_related(\*(Aqauthor\*(Aq, $author_obj);
.Ve
.PP
The same as \*(L"set_from_related\*(R", but the changes are immediately updated
in storage.
.SS "delete_related"
.IX Subsection "delete_related"
.Vb 1
\&  $obj\->delete_related(\*(Aqrelname\*(Aq, $cond, $attrs);
.Ve
.PP
Delete any related item subject to the given conditions.
.SS "add_to_$rel"
.IX Subsection "add_to_$rel"
\&\fBCurrently only available for \f(CB\*(C`has_many\*(C'\fB, \f(CB\*(C`many\-to\-many\*(C'\fB and 'multi' type
relationships.\fR
.ie n .IP "Arguments: ($foreign_vals | $obj), $link_vals?" 4
.el .IP "Arguments: ($foreign_vals | \f(CW$obj\fR), \f(CW$link_vals\fR?" 4
.IX Item "Arguments: ($foreign_vals | $obj), $link_vals?"
.PP
.Vb 3
\&  my $role = $schema\->resultset(\*(AqRole\*(Aq)\->find(1);
\&  $actor\->add_to_roles($role);
\&      # creates a My::DBIC::Schema::ActorRoles linking table row object
\&
\&  $actor\->add_to_roles({ name => \*(Aqlead\*(Aq }, { salary => 15_000_000 });
\&      # creates a new My::DBIC::Schema::Role row object and the linking table
\&      # object with an extra column in the link
.Ve
.PP
Adds a linking table object for \f(CW$obj\fR or \f(CW$foreign_vals\fR. If the first
argument is a hash reference, the related object is created first with the
column values in the hash. If an object reference is given, just the linking
table object is created. In either case, any additional column values for the
linking table object can be specified in \f(CW$link_vals\fR.
.SS "set_$rel"
.IX Subsection "set_$rel"
\&\fBCurrently only available for \f(CB\*(C`many\-to\-many\*(C'\fB relationships.\fR
.ie n .IP "Arguments: (\e@hashrefs | \e@objs), $link_vals?" 4
.el .IP "Arguments: (\e@hashrefs | \e@objs), \f(CW$link_vals\fR?" 4
.IX Item "Arguments: (@hashrefs | @objs), $link_vals?"
.PP
.Vb 3
\&  my $actor = $schema\->resultset(\*(AqActor\*(Aq)\->find(1);
\&  my @roles = $schema\->resultset(\*(AqRole\*(Aq)\->search({ role =>
\&     { \*(Aq\-in\*(Aq => [\*(AqFred\*(Aq, \*(AqBarney\*(Aq] } } );
\&
\&  $actor\->set_roles(\e@roles);
\&     # Replaces all of $actor\*(Aqs previous roles with the two named
\&
\&  $actor\->set_roles(\e@roles, { salary => 15_000_000 });
\&     # Sets a column in the link table for all roles
.Ve
.PP
Replace all the related objects with the given reference to a list of
objects. This does a \f(CW\*(C`delete\*(C'\fR \fBon the link table resultset\fR to remove the
association between the current object and all related objects, then calls
\&\f(CW\*(C`add_to_$rel\*(C'\fR repeatedly to link all the new objects.
.PP
Note that this means that this method will \fBnot\fR delete any objects in the
table on the right side of the relation, merely that it will delete the link
between them.
.PP
Due to a mistake in the original implementation of this method, it will also
accept a list of objects or hash references. This is \fBdeprecated\fR and will be
removed in a future version.
.SS "remove_from_$rel"
.IX Subsection "remove_from_$rel"
\&\fBCurrently only available for \f(CB\*(C`many\-to\-many\*(C'\fB relationships.\fR
.ie n .IP "Arguments: $obj" 4
.el .IP "Arguments: \f(CW$obj\fR" 4
.IX Item "Arguments: $obj"
.PP
.Vb 3
\&  my $role = $schema\->resultset(\*(AqRole\*(Aq)\->find(1);
\&  $actor\->remove_from_roles($role);
\&      # removes $role\*(Aqs My::DBIC::Schema::ActorRoles linking table row object
.Ve
.PP
Removes the link between the current object and the related object. Note that
the related object itself won't be deleted unless you call \->\fIdelete()\fR on
it. This method just removes the link between the two objects.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt S. Trout <mst@shadowcatsystems.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
