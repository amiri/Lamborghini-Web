.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema::Loader::Base 3"
.TH DBIx::Class::Schema::Loader::Base 3 "2010-09-10" "perl v5.12.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Schema::Loader::Base \- Base DBIx::Class::Schema::Loader Implementation.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See DBIx::Class::Schema::Loader
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for the storage-specific \f(CW\*(C`DBIx::Class::Schema::*\*(C'\fR
classes, and implements the common functionality between them.
.SH "CONSTRUCTOR OPTIONS"
.IX Header "CONSTRUCTOR OPTIONS"
These constructor options are the base options for
\&\*(L"loader_options\*(R" in DBIx::Class::Schema::Loader.  Available constructor options are:
.SS "skip_relationships"
.IX Subsection "skip_relationships"
Skip setting up relationships.  The default is to attempt the loading
of relationships.
.SS "skip_load_external"
.IX Subsection "skip_load_external"
Skip loading of other classes in \f(CW@INC\fR. The default is to merge all other classes
with the same name found in \f(CW@INC\fR into the schema file we are creating.
.SS "naming"
.IX Subsection "naming"
Static schemas (ones dumped to disk) will, by default, use the new-style
relationship names and singularized Results, unless you're overwriting an
existing dump made by an older version of DBIx::Class::Schema::Loader, in
which case the backward compatible RelBuilder will be activated, and the
appropriate monikerization used.
.PP
Specifying
.PP
.Vb 1
\&    naming => \*(Aqcurrent\*(Aq
.Ve
.PP
will disable the backward-compatible RelBuilder and use
the new-style relationship names along with singularized Results, even when
overwriting a dump made with an earlier version.
.PP
The option also takes a hashref:
.PP
.Vb 1
\&    naming => { relationships => \*(Aqv7\*(Aq, monikers => \*(Aqv7\*(Aq }
.Ve
.PP
The keys are:
.IP "relationships" 4
.IX Item "relationships"
How to name relationship accessors.
.IP "monikers" 4
.IX Item "monikers"
How to name Result classes.
.IP "column_accessors" 4
.IX Item "column_accessors"
How to name column accessors in Result classes.
.PP
The values can be:
.IP "current" 4
.IX Item "current"
Latest style, whatever that happens to be.
.IP "v4" 4
.IX Item "v4"
Unsingularlized monikers, \f(CW\*(C`has_many\*(C'\fR only relationships with no _id stripping.
.IP "v5" 4
.IX Item "v5"
Monikers singularized as whole words, \f(CW\*(C`might_have\*(C'\fR relationships for FKs on
\&\f(CW\*(C`UNIQUE\*(C'\fR constraints, \f(CW\*(C`_id\*(C'\fR stripping for belongs_to relationships.
.Sp
Some of the \f(CW\*(C`_id\*(C'\fR stripping edge cases in \f(CW0.05003\fR have been reverted for
the v5 RelBuilder.
.IP "v6" 4
.IX Item "v6"
All monikers and relationships are inflected using
Lingua::EN::Inflect::Phrase, and there is more aggressive \f(CW\*(C`_id\*(C'\fR stripping
from relationship names.
.Sp
In general, there is very little difference between v5 and v6 schemas.
.IP "v7" 4
.IX Item "v7"
This mode is identical to \f(CW\*(C`v6\*(C'\fR mode, except that monikerization of CamelCase
table names is also done correctly.
.Sp
CamelCase column names in case-preserving mode will also be handled correctly
for relationship name inflection. See \*(L"preserve_case\*(R".
.Sp
In this mode, CamelCase \*(L"column_accessors\*(R" are normalized based on case
transition instead of just being lowercased, so \f(CW\*(C`FooId\*(C'\fR becomes \f(CW\*(C`foo_id\*(C'\fR.
.Sp
If you don't have any CamelCase table or column names, you can upgrade without
breaking any of your code.
.PP
Dynamic schemas will always default to the 0.04XXX relationship names and won't
singularize Results for backward compatibility, to activate the new RelBuilder
and singularization put this in your \f(CW\*(C`Schema.pm\*(C'\fR file:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->naming(\*(Aqcurrent\*(Aq);
.Ve
.PP
Or if you prefer to use 0.07XXX features but insure that nothing breaks in the
next major version upgrade:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->naming(\*(Aqv7\*(Aq);
.Ve
.SS "generate_pod"
.IX Subsection "generate_pod"
By default \s-1POD\s0 will be generated for columns and relationships, using database
metadata for the text if available and supported.
.PP
Reading database metadata (e.g. \f(CW\*(C`COMMENT ON TABLE some_table ...\*(C'\fR) is only
supported for Postgres right now.
.PP
Set this to \f(CW0\fR to turn off all \s-1POD\s0 generation.
.SS "pod_comment_mode"
.IX Subsection "pod_comment_mode"
Controls where table comments appear in the generated \s-1POD\s0. Smaller table
comments are appended to the \f(CW\*(C`NAME\*(C'\fR section of the documentation, and larger
ones are inserted into \f(CW\*(C`DESCRIPTION\*(C'\fR instead. You can force a \f(CW\*(C`DESCRIPTION\*(C'\fR
section to be generated with the comment always, only use \f(CW\*(C`NAME\*(C'\fR, or choose
the length threshold at which the comment is forced into the description.
.IP "name" 4
.IX Item "name"
Use \f(CW\*(C`NAME\*(C'\fR section only.
.IP "description" 4
.IX Item "description"
Force \f(CW\*(C`DESCRIPTION\*(C'\fR always.
.IP "auto" 4
.IX Item "auto"
Use \f(CW\*(C`DESCRIPTION\*(C'\fR if length > \*(L"pod_comment_spillover_length\*(R", this is the
default.
.SS "pod_comment_spillover_length"
.IX Subsection "pod_comment_spillover_length"
When pod_comment_mode is set to \f(CW\*(C`auto\*(C'\fR, this is the length of the comment at
which it will be forced into a separate description section.
.PP
The default is \f(CW60\fR
.SS "relationship_attrs"
.IX Subsection "relationship_attrs"
Hashref of attributes to pass to each generated relationship, listed
by type.  Also supports relationship type 'all', containing options to
pass to all generated relationships.  Attributes set for more specific
relationship types override those set in 'all'.
.PP
For example:
.PP
.Vb 3
\&  relationship_attrs => {
\&    belongs_to => { is_deferrable => 0 },
\&  },
.Ve
.PP
use this to turn off \s-1DEFERRABLE\s0 on your foreign key constraints.
.SS "debug"
.IX Subsection "debug"
If set to true, each constructive DBIx::Class statement the loader
decides to execute will be \f(CW\*(C`warn\*(C'\fR\-ed before execution.
.SS "db_schema"
.IX Subsection "db_schema"
Set the name of the schema to load (schema in the sense that your database
vendor means it).  Does not currently support loading more than one schema
name.
.SS "constraint"
.IX Subsection "constraint"
Only load tables matching regex.  Best specified as a qr// regex.
.SS "exclude"
.IX Subsection "exclude"
Exclude tables matching regex.  Best specified as a qr// regex.
.SS "moniker_map"
.IX Subsection "moniker_map"
Overrides the default table name to moniker translation.  Can be either
a hashref of table keys and moniker values, or a coderef for a translator
function taking a single scalar table name argument and returning
a scalar moniker.  If the hash entry does not exist, or the function
returns a false value, the code falls back to default behavior
for that table name.
.PP
The default behavior is to split on case transition and non-alphanumeric
boundaries, singularize the resulting phrase, then join the titlecased words
together. Examples:
.PP
.Vb 7
\&    Table Name       | Moniker Name
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    luser            | Luser
\&    luser_group      | LuserGroup
\&    luser\-opts       | LuserOpt
\&    stations_visited | StationVisited
\&    routeChange      | RouteChange
.Ve
.SS "inflect_plural"
.IX Subsection "inflect_plural"
Just like \*(L"moniker_map\*(R" above (can be hash/code\-ref, falls back to default
if hash key does not exist or coderef returns false), but acts as a map
for pluralizing relationship names.  The default behavior is to utilize
\&\*(L"to_PL\*(R" in Lingua::EN::Inflect::Number.
.SS "inflect_singular"
.IX Subsection "inflect_singular"
As \*(L"inflect_plural\*(R" above, but for singularizing relationship names.
Default behavior is to utilize \*(L"to_S\*(R" in Lingua::EN::Inflect::Number.
.SS "schema_base_class"
.IX Subsection "schema_base_class"
Base class for your schema classes. Defaults to 'DBIx::Class::Schema'.
.SS "result_base_class"
.IX Subsection "result_base_class"
Base class for your table classes (aka result classes). Defaults to
\&'DBIx::Class::Core'.
.SS "additional_base_classes"
.IX Subsection "additional_base_classes"
List of additional base classes all of your table classes will use.
.SS "left_base_classes"
.IX Subsection "left_base_classes"
List of additional base classes all of your table classes will use
that need to be leftmost.
.SS "additional_classes"
.IX Subsection "additional_classes"
List of additional classes which all of your table classes will use.
.SS "components"
.IX Subsection "components"
List of additional components to be loaded into all of your table
classes.  A good example would be
InflateColumn::DateTime
.SS "resultset_components"
.IX Subsection "resultset_components"
List of additional ResultSet components to be loaded into your table
classes.  A good example would be \f(CW\*(C`AlwaysRS\*(C'\fR.  Component
\&\f(CW\*(C`ResultSetManager\*(C'\fR will be automatically added to the above
\&\f(CW\*(C`components\*(C'\fR list if this option is set.
.SS "use_namespaces"
.IX Subsection "use_namespaces"
This is now the default, to go back to \*(L"load_classes\*(R" in DBIx::Class::Schema pass
a \f(CW0\fR.
.PP
Generate result class names suitable for
\&\*(L"load_namespaces\*(R" in DBIx::Class::Schema and call that instead of
\&\*(L"load_classes\*(R" in DBIx::Class::Schema. When using this option you can also
specify any of the options for \f(CW\*(C`load_namespaces\*(C'\fR (i.e. \f(CW\*(C`result_namespace\*(C'\fR,
\&\f(CW\*(C`resultset_namespace\*(C'\fR, \f(CW\*(C`default_resultset_class\*(C'\fR), and they will be added
to the call (and the generated result class names adjusted appropriately).
.SS "dump_directory"
.IX Subsection "dump_directory"
This option is designed to be a tool to help you transition from this
loader to a manually-defined schema when you decide it's time to do so.
.PP
The value of this option is a perl libdir pathname.  Within
that directory this module will create a baseline manual
DBIx::Class::Schema module set, based on what it creates at runtime
in memory.
.PP
The created schema class will have the same classname as the one on
which you are setting this option (and the ResultSource classes will be
based on this name as well).
.PP
Normally you wouldn't hard-code this setting in your schema class, as it
is meant for one-time manual usage.
.PP
See \*(L"dump_to_dir\*(R" in DBIx::Class::Schema::Loader for examples of the
recommended way to access this functionality.
.SS "dump_overwrite"
.IX Subsection "dump_overwrite"
Deprecated.  See \*(L"really_erase_my_files\*(R" below, which does *not* mean
the same thing as the old \f(CW\*(C`dump_overwrite\*(C'\fR setting from previous releases.
.SS "really_erase_my_files"
.IX Subsection "really_erase_my_files"
Default false.  If true, Loader will unconditionally delete any existing
files before creating the new ones from scratch when dumping a schema to disk.
.PP
The default behavior is instead to only replace the top portion of the
file, up to and including the final stanza which contains
\&\f(CW\*(C`# DO NOT MODIFY THIS OR ANYTHING ABOVE!\*(C'\fR
leaving any customizations you placed after that as they were.
.PP
When \f(CW\*(C`really_erase_my_files\*(C'\fR is not set, if the output file already exists,
but the aforementioned final stanza is not found, or the checksum
contained there does not match the generated contents, Loader will
croak and not touch the file.
.PP
You should really be using version control on your schema classes (and all
of the rest of your code for that matter).  Don't blame me if a bug in this
code wipes something out when it shouldn't have, you've been warned.
.SS "overwrite_modifications"
.IX Subsection "overwrite_modifications"
Default false.  If false, when updating existing files, Loader will
refuse to modify any Loader-generated code that has been modified
since its last run (as determined by the checksum Loader put in its
comment lines).
.PP
If true, Loader will discard any manual modifications that have been
made to Loader-generated code.
.PP
Again, you should be using version control on your schema classes.  Be
careful with this option.
.SS "custom_column_info"
.IX Subsection "custom_column_info"
Hook for adding extra attributes to the
column_info for a column.
.PP
Must be a coderef that returns a hashref with the extra attributes.
.PP
Receives the table name, column name and column_info.
.PP
For example:
.PP
.Vb 2
\&  custom_column_info => sub {
\&      my ($table_name, $column_name, $column_info) = @_;
\&
\&      if ($column_name eq \*(Aqdog\*(Aq && $column_info\->{default_value} eq \*(Aqsnoopy\*(Aq) {
\&          return { is_snoopy => 1 };
\&      }
\&  },
.Ve
.PP
This attribute can also be used to set \f(CW\*(C`inflate_datetime\*(C'\fR on a non-datetime
column so it also receives the \*(L"datetime_timezone\*(R" and/or \*(L"datetime_locale\*(R".
.SS "datetime_timezone"
.IX Subsection "datetime_timezone"
Sets the timezone attribute for DBIx::Class::InflateColumn::DateTime for all
columns with the \s-1DATE/DATETIME/TIMESTAMP\s0 data_types.
.SS "datetime_locale"
.IX Subsection "datetime_locale"
Sets the locale attribute for DBIx::Class::InflateColumn::DateTime for all
columns with the \s-1DATE/DATETIME/TIMESTAMP\s0 data_types.
.SS "config_file"
.IX Subsection "config_file"
File in Perl format, which should return a \s-1HASH\s0 reference, from which to read
loader options.
.SS "preserve_case"
.IX Subsection "preserve_case"
Usually column names are lowercased, to make them easier to work with in
DBIx::Class. This option lets you turn this behavior off, if the driver
supports it.
.PP
Drivers for case sensitive databases like Sybase \s-1ASE\s0 or \s-1MSSQL\s0 with a
case-sensitive collation will turn this option on unconditionally.
.PP
Currently the drivers for SQLite, mysql, \s-1MSSQL\s0 and Firebird/InterBase support
setting this option.
.SS "qualify_objects"
.IX Subsection "qualify_objects"
Set to true to prepend the \*(L"db_schema\*(R" to table names for \f(CW\*(C`_\|_PACKAGE_\|_\->table\*(C'\fR calls, and to some other things like Oracle sequences.
.SS "use_moose"
.IX Subsection "use_moose"
Creates Schema and Result classes that use Moose, MooseX::NonMoose and
namespace::autoclean. The default content after the md5 sum also makes the
classes immutable.
.PP
It is safe to upgrade your existing Schema to this option.
.SH "METHODS"
.IX Header "METHODS"
None of these methods are intended for direct invocation by regular
users of DBIx::Class::Schema::Loader. Some are proxied via
DBIx::Class::Schema::Loader.
.SS "new"
.IX Subsection "new"
Constructor for DBIx::Class::Schema::Loader::Base, used internally
by DBIx::Class::Schema::Loader.
.SS "load"
.IX Subsection "load"
Does the actual schema-construction work.
.SS "rescan"
.IX Subsection "rescan"
Arguments: schema
.PP
Rescan the database for changes. Returns a list of the newly added table
monikers.
.PP
The schema argument should be the schema class or object to be affected.  It
should probably be derived from the original schema_class used during \*(L"load\*(R".
.SS "tables"
.IX Subsection "tables"
Returns a sorted list of loaded tables, using the original database table
names.
.SS "monikers"
.IX Subsection "monikers"
Returns a hashref of loaded table to moniker mappings.  There will
be two entries for each table, the original name and the \*(L"normalized\*(R"
name, in the case that the two are different (such as databases
that like uppercase table names, or preserve your original mixed-case
definitions, or what-have-you).
.SS "classes"
.IX Subsection "classes"
Returns a hashref of table to class mappings.  In some cases it will
contain multiple entries per table for the original and normalized table
names, as above in \*(L"monikers\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Class::Schema::Loader
.SH "AUTHOR"
.IX Header "AUTHOR"
See \*(L"\s-1AUTHOR\s0\*(R" in DBIx::Class::Schema::Loader and \*(L"\s-1CONTRIBUTORS\s0\*(R" in DBIx::Class::Schema::Loader.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
